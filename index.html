<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Песочные часы — до 15 ноября 2025</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--accent:#6ee7b7;--muted:#9aa4b2}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:linear-gradient(180deg,#071022 0%, #07142a 60%);
      color:#e6eef6; font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
      display:flex;align-items:center;justify-content:center;padding:24px;
    }
    .wrap{width:100%;max-width:920px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:22px;box-shadow:0 8px 40px rgba(2,6,23,0.7);display:grid;grid-template-columns:1fr 360px;gap:18px;align-items:center}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 14px;color:var(--muted)}

    /* Left: numeric countdown */
    .left{padding:8px 12px}
    .nums{display:flex;gap:12px;flex-wrap:wrap}
    .pill{background:rgba(255,255,255,0.02);padding:12px 18px;border-radius:12px;min-width:100px;text-align:center}
    .number{font-weight:700;font-size:26px;color:var(--accent)}
    .label{font-size:12px;color:var(--muted);margin-top:6px}

    /* Right: hourglass */
    .glass-wrap{display:flex;align-items:center;justify-content:center}
    .hourglass{width:300px;height:420px;position:relative}
    svg.hour{width:100%;height:100%;display:block}
    .chamber{position:absolute;left:50%;transform:translateX(-50%);width:160px;height:160px;overflow:visible}
    .top{top:46px}
    .bottom{bottom:46px}
    .neck{top:198px;left:50%;transform:translateX(-50%);width:24px;height:44px}

    /* penguins as absolute items inside chambers */
    .peng{position:absolute;width:18px;height:22px;transform-origin:center;will-change:transform,opacity}
    .peng svg{width:100%;height:100%;display:block}

    /* stack in bottom: pengs align in rows */
    .bottom .peng{transition:transform 600ms cubic-bezier(.2,.9,.2,1),opacity 400ms}

    /* controls */
    .meta{display:flex;gap:8px;align-items:center;margin-top:10px}
    input[type="date"], button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:8px}
    button.primary{background:var(--accent);color:#032022;border:0}

    footer{margin-top:12px;color:var(--muted);font-size:13px}

    @media (max-width:880px){.card{grid-template-columns:1fr;}.hourglass{width:260px;height:360px}}

    /* dissolve animation */
    @keyframes dissolve{
      0%{opacity:1;transform:scale(1)}
      100%{opacity:0;transform:scale(1.6) translateY(20px)}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="left">
        <h1>Перекидные песочные часы — до 15 ноября 2025</h1>
        <p class="lead">Минималистичный таймер с милыми пингвинчиками: каждый минутный тик — один пингвин падает. Каждые 60 минут они растворяются внизу.</p>

        <div class="nums">
          <div class="pill"><div class="number" id="days">0</div><div class="label">Дней</div></div>
          <div class="pill"><div class="number" id="hours">0</div><div class="label">Часов</div></div>
          <div class="pill"><div class="number" id="minutes">0</div><div class="label">Минут</div></div>
          <div class="pill"><div class="number" id="seconds">0</div><div class="label">Секунд</div></div>
        </div>

        <div class="meta">
          <label style="display:flex;gap:8px;align-items:center"><span style="color:var(--muted);font-size:13px">Цель</span>
            <input id="targetName" type="text" placeholder="Встреча, дедлайн..." style="min-width:180px" />
          </label>
          <button id="shareBtn" class="primary">Сохранить ссылку</button>
        </div>

        <footer>Сохрани страницу (Ctrl/Cmd+S) или загрузи на GitHub Pages — ссылка сохранит дату/название в URL.</footer>
      </div>

      <div class="glass-wrap">
        <div class="hourglass" role="img" aria-label="Песочные часы">
          <!-- SVG рамка часов -->
          <svg class="hour" viewBox="0 0 200 280" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <defs>
              <linearGradient id="g1" x1="0" x2="1">
                <stop offset="0%" stop-color="#6ee7b7" />
                <stop offset="100%" stop-color="#60a5fa" />
              </linearGradient>
            </defs>
            <rect x="10" y="8" width="180" height="16" rx="4" fill="rgba(255,255,255,0.03)"/>
            <rect x="10" y="256" width="180" height="16" rx="4" fill="rgba(255,255,255,0.03)"/>
            <path d="M40 24 C70 90,70 190,40 256" stroke="rgba(255,255,255,0.06)" stroke-width="6" fill="none" stroke-linecap="round"/>
            <path d="M160 24 C130 90,130 190,160 256" stroke="rgba(255,255,255,0.06)" stroke-width="6" fill="none" stroke-linecap="round"/>
            <!-- glass interior subtle -->
            <ellipse cx="100" cy="70" rx="38" ry="16" fill="rgba(255,255,255,0.02)" />
            <ellipse cx="100" cy="210" rx="38" ry="16" fill="rgba(255,255,255,0.02)" />
          </svg>

          <!-- top chamber: penguins will be injected here -->
          <div class="chamber top" id="topChamber" style="width:140px;height:140px;">
          </div>

          <!-- neck indicator (visual only) -->
          <div class="neck" aria-hidden="true"></div>

          <!-- bottom chamber -->
          <div class="chamber bottom" id="bottomChamber" style="width:140px;height:140px;">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Target date: 15 Nov 2025 00:00 local time
    const target = new Date('2025-11-15T00:00:00');

    const daysEl = document.getElementById('days');
    const hoursEl = document.getElementById('hours');
    const minutesEl = document.getElementById('minutes');
    const secondsEl = document.getElementById('seconds');
    const topChamber = document.getElementById('topChamber');
    const bottomChamber = document.getElementById('bottomChamber');
    const targetName = document.getElementById('targetName');
    const shareBtn = document.getElementById('shareBtn');

    // Keep arrays of penguins
    let bottomPengs = []; // DOM elements
    let topPengsCount = 0; // visual count in top

    // simple penguin SVG as a string
    function penguinSVG(){
      return `
      <svg viewBox="0 0 64 80" xmlns="http://www.w3.org/2000/svg">
        <g>
          <ellipse cx="32" cy="42" rx="20" ry="26" fill="#0f1724" />
          <ellipse cx="32" cy="42" rx="12" ry="18" fill="#fff" />
          <circle cx="24" cy="36" r="3" fill="#08121a" />
          <circle cx="40" cy="36" r="3" fill="#08121a" />
          <path d="M32 50 l-5 6 l10 0 z" fill="#f6b26b" />
        </g>
      </svg>`;
    }

    // Create a penguin element positioned in top chamber (not yet animated)
    function createPeng(position){
      const el = document.createElement('div');
      el.className = 'peng';
      el.innerHTML = penguinSVG();
      // random x within chamber width
      const chamberW = topChamber.clientWidth || 140;
      const x = 10 + Math.random()*(chamberW-36);
      el.style.left = x + 'px';
      el.style.top = (10 + Math.random()*40) + 'px';
      el.style.opacity = '1';
      topChamber.appendChild(el);
      topPengsCount++;
      return el;
    }

    // Drop one peng from top to bottom with animation
    function dropOnePeng(){
      // pick or create a top penguin
      let t = topChamber.querySelector('.peng');
      if(!t){
        t = createPeng();
      }
      // compute bottom target position (stack)
      const idx = bottomPengs.length;
      const cols = 7; // penguins per row
      const row = Math.floor(idx/cols);
      const col = idx % cols;
      const cellW = 18; const cellH = 22; const gap = 4;
      const bottomW = bottomChamber.clientWidth || 140;
      const baseLeft = (bottomW - (cols*cellW + (cols-1)*gap))/2;
      const targetX = baseLeft + col*(cellW+gap);
      const targetY = bottomChamber.clientHeight - (row+1)*(cellH+gap) - 6;

      // get current position of t relative to hourglass
      const startRect = t.getBoundingClientRect();
      const containerRect = topChamber.getBoundingClientRect();

      // convert to chamber coordinates
      const startX = parseFloat(t.style.left || 0);
      const startY = parseFloat(t.style.top || 0);

      // animate using transform
      t.style.transition = 'transform 900ms cubic-bezier(.2,.9,.2,1), opacity 600ms linear';
      const dx = (targetX - startX);
      const dy = ( (bottomChamber.offsetTop - topChamber.offsetTop) + targetY - startY );
      t.style.transform = `translate(${dx}px, ${dy}px) scale(0.95)`;

      // after animation ends, move it into bottom chamber and position absolutely inside bottom
      setTimeout(()=>{
        // cleanup transform
        t.style.transition = '';
        t.style.transform = '';
        // remove from top
        topChamber.removeChild(t);
        // place in bottom
        t.style.left = targetX + 'px';
        t.style.top = targetY + 'px';
        bottomChamber.appendChild(t);
        bottomPengs.push(t);
        rearrangeBottom();
      }, 950);
    }

    // Rearrange bottom penguins smoothly (stack them)
    function rearrangeBottom(){
      const cols = 7; const cellW = 18; const cellH = 22; const gap = 4;
      const bottomW = bottomChamber.clientWidth || 140;
      const baseLeft = (bottomW - (cols*cellW + (cols-1)*gap))/2;
      bottomPengs.forEach((p, idx)=>{
        const row = Math.floor(idx/cols);
        const col = idx % cols;
        const x = baseLeft + col*(cellW+gap);
        const y = bottomChamber.clientHeight - (row+1)*(cellH+gap) - 6;
        p.style.transform = `translate(${x - parseFloat(p.style.left || 0)}px, ${y - parseFloat(p.style.top || 0)}px)`;
        // after transition reset absolute coords
        setTimeout(()=>{
          p.style.transform = '';
          p.style.left = x + 'px';
          p.style.top = y + 'px';
        }, 620);
      });
    }

    // dissolve bottom penguins (called each hour)
    function dissolveBottom(){
      bottomPengs.forEach((p, i)=>{
        p.style.animation = `dissolve 800ms ease ${i*14}ms forwards`;
      });
      setTimeout(()=>{
        bottomPengs.forEach(p=>{ if(p.parentNode) p.parentNode.removeChild(p); });
        bottomPengs = [];
      }, 1400 + bottomPengs.length*14);
    }

    // initialize top chamber with 60 - minutesPassedInHour pengs visually
    function initPenguins(){
      const now = new Date();
      const minutesPast = now.getMinutes();
      // bottom should have minutesPast pengs stacked
      for(let i=0;i<minutesPast;i++){
        const p = document.createElement('div'); p.className='peng'; p.innerHTML = penguinSVG();
        // compute position
        const cols = 7; const cellW = 18; const gap = 4;
        const bottomW = bottomChamber.clientWidth || 140; const baseLeft = (bottomW - (cols*cellW + (cols-1)*gap))/2;
        const row = Math.floor(i/cols); const col = i%cols;
        const x = baseLeft + col*(cellW+gap);
        const y = bottomChamber.clientHeight - (row+1)*(cellW+gap) - 6;
        p.style.left = x + 'px'; p.style.top = y + 'px';
        bottomChamber.appendChild(p);
        bottomPengs.push(p);
      }
      // fill top with remaining to 60
      const topNeed = 60 - minutesPast;
      for(let i=0;i<Math.min(12, topNeed); i++){
        const p = document.createElement('div'); p.className='peng'; p.innerHTML = penguinSVG();
        p.style.left = (12 + i*20) + 'px'; p.style.top = (12 + (i%3)*16) + 'px';
        topChamber.appendChild(p);
      }
    }

    // Update numeric countdown
    function updateNumbers(){
      const now = new Date();
      let diff = target - now;
      if(diff<=0){ daysEl.textContent='0'; hoursEl.textContent='0'; minutesEl.textContent='0'; secondsEl.textContent='0'; return; }
      const s = Math.floor(diff/1000);
      const days = Math.floor(s/86400); const hours = Math.floor((s%86400)/3600);
      const mins = Math.floor((s%3600)/60); const secs = s%60;
      daysEl.textContent = days; hoursEl.textContent=hours; minutesEl.textContent=mins; secondsEl.textContent=secs;
    }

    // main tick every second, but we care about minute changes
    let lastMinute = new Date().getMinutes();
    function tick(){
      updateNumbers();
      const now = new Date();
      const m = now.getMinutes();
      if(m !== lastMinute){
        // minute changed -> drop one
        lastMinute = m;
        dropOnePeng();
      }
      // if minute==0 -> new hour -> dissolve bottom
      if(now.getMinutes()===0 && now.getSeconds()<2){
        // small guard: trigger dissolve when minute rolls to 0
        dissolveBottom();
      }
    }

    // share button: encode name & target in URL
    shareBtn.addEventListener('click', ()=>{
      const name = targetName.value || '';
      const u = new URL(location.href);
      u.searchParams.set('t', name);
      u.searchParams.set('d', target.toISOString());
      history.replaceState(null,null,u.toString());
      alert('Ссылка сохранена в адресной строке. Сохрани страницу и отправь её коллеге.');
    });

    // restore from URL
    (function restoreFromURL(){
      const p = new URLSearchParams(location.search);
      if(p.get('d')){
        const d = new Date(p.get('d'));
        if(!isNaN(d)){
          // override target
        }
      }
      if(p.get('t')) targetName.value = p.get('t');
    })();

    // initial
    initPenguins();
    updateNumbers();
    setInterval(tick,1000);

    // responsive rearrange on resize
    window.addEventListener('resize', ()=>{ rearrangeBottom(); });

  </script>
</body>
</html>
